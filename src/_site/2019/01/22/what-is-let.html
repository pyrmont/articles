<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>What is let*? | articles.inqk.net</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="What is let*?" />
<meta name="author" content="Michael Camilleri" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="An investigation into the difference between let and let* in Clojure." />
<meta property="og:description" content="An investigation into the difference between let and let* in Clojure." />
<link rel="canonical" href="http://localhost:4000/2019/01/22/what-is-let.html" />
<meta property="og:url" content="http://localhost:4000/2019/01/22/what-is-let.html" />
<meta property="og:site_name" content="articles.inqk.net" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-22T14:18:24+09:00" />
<script type="application/ld+json">
{"dateModified":"2019-02-13T03:12:49+09:00","datePublished":"2019-01-22T14:18:24+09:00","headline":"What is let*?","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/01/22/what-is-let.html"},"author":{"@type":"Person","name":"Michael Camilleri"},"description":"An investigation into the difference between let and let* in Clojure.","url":"http://localhost:4000/2019/01/22/what-is-let.html","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/assets/css/style.css?v=2daa2b27c8b7174fdff1f614d852c8ece5845587">
    <link rel="stylesheet" href="/assets/css/barefoot.min.css?v=2daa2b27c8b7174fdff1f614d852c8ece5845587">
    <link rel="alternate" type="application/atom+xml" href="/feed.xml" />

    <link rel="shortcut icon" href="/assets/icons/favicon.ico?v=2daa2b27c8b7174fdff1f614d852c8ece5845587" />
    <link rel="icon" type="image/png" href="/assets/icons/favicon-196.png?v=2daa2b27c8b7174fdff1f614d852c8ece5845587" sizes="196x196">
    <link rel="apple-touch-icon image_src" href="/assets/icons/apple-touch-icon.png?v=2daa2b27c8b7174fdff1f614d852c8ece5845587">

    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header class="post">
        <a href="http://localhost:4000"> <h1>&#10042; articles.inqk.net</h1> </a>
        <p>Usually more extended thoughts by <a href="https://inqk.net/">Michael Camilleri</a>.
</p>
        <p class="instructions">Read <a href="/instructions.html">how</a> to use this blog.</p>
      </header>

<section class="post">
  <div class="tldr">
    <div class="heading">TLDR</div>
    <p>An investigation into the difference between <code>let</code> and <code>let*</code> in Clojure.</p>

  </div>

  <article>
    <h1>What is <code>let*</code>?
</h1>

    <div class="metadata">
      <time datetime="2019-01-22 14:18:24 +0900">22 January 2019</time>
      <span class="history"><a href="https://github.com/pyrmont/articles/commits/master/_posts/2019-01-22-what-is-let.md">Revision History</a></span>
    </div>

    <h2>The Problem</h2>
<p>In <a href="https://www.braveclojure.com/writing-macros/">Chapter 8</a> of Daniel Higginbotham’s very good book, <em>Clojure for the Brave and True</em>, we define the macro <code>if-valid</code>. I won’t go into much detail about the context except to say that the macro involves the use of <code>let</code>.</p>
<p>Later in the chapter, we’re directed to use the function <code>macroexpand</code> to expand the <code>if-valid</code> macro. Here’s the relevant code listing:<span class="connector">&#65279;<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup></span></p>
<pre class="code highlight language-clj"><code><span class="line-1"><span class="p">(</span><span class="nb">macroexpand</span></span>
<span class="line-2"><span class="w"> </span><span class="o">'</span><span class="p">(</span><span class="n">if-valid</span><span class="w"> </span><span class="n">order-details</span><span class="w"> </span><span class="n">order-details-validations</span><span class="w"> </span><span class="n">my-error-name</span><span class="o">#</span></span>
<span class="line-3"><span class="w">            </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="no">:success</span><span class="p">)</span></span>
<span class="line-4"><span class="w">            </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="no">:failure</span><span class="w"> </span><span class="n">my-error-name</span><span class="o">#</span><span class="p">)))</span></span>
<span class="line-5"><span class="c1">; =&gt; (let*</span></span>
<span class="line-6"><span class="c1">; =&gt; [my-error-name__3737__auto (user/validate order-details order-details-validations)]</span></span>
<span class="line-7"><span class="c1">; =&gt; (if (clojure.core/empty? my-error-name__3737__auto)</span></span>
<span class="line-8"><span class="c1">; =&gt;  (println :success)</span></span>
<span class="line-9"><span class="c1">; =&gt;  (println :failure my-error-name__3737__auto)))</span></span>
</code></pre>
<p>Wait, <code>let*</code>? What’s that? That’s not what we wrote. What’s going on here?</p>
<h2>Special Forms</h2>
<p>One of the most elegant aspects of Lisp is that it can be implemented using a very small number of special forms.<span class="connector">&#65279;<sup class="footnote-ref"><a href="#fn2" id="fnref2">2</a></sup></span> One of the ones that Clojure uses is commonly said to be <code>let</code>.</p>
<p>The thing is <code>let</code> isn’t a special form.<span class="connector">&#65279;<sup class="footnote-ref"><a href="#fn3" id="fnref3">3</a></sup></span> Indeed, typing <code>(doc let)</code> into a REPL will tell you that <code>let</code> is in fact a macro. If you run <code>(source let)</code>, you’ll be presented with the following:</p>
<pre class="code highlight language-clj"><code><span class="line-1"><span class="p">(</span><span class="kd">defmacro</span><span class="w"> </span><span class="k">let</span></span>
<span class="line-2"><span class="w">  </span><span class="s">"binding =&gt; binding-form init-expr</span></span>
<span class="line-3"></span>
<span class="line-4"><span class="s">  Evaluates the exprs in a lexical context in which the symbols in</span></span>
<span class="line-5"><span class="s">  the binding-forms are bound to their respective init-exprs or parts</span></span>
<span class="line-6"><span class="s">  therein."</span></span>
<span class="line-7"><span class="w">  </span><span class="p">{</span><span class="no">:added</span><span class="w"> </span><span class="s">"1.0"</span><span class="n">,</span><span class="w"> </span><span class="no">:special-form</span><span class="w"> </span><span class="n">true,</span><span class="w"> </span><span class="no">:forms</span><span class="w"> </span><span class="o">'</span><span class="p">[(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">bindings*</span><span class="p">]</span><span class="w"> </span><span class="n">exprs*</span><span class="p">)]}</span></span>
<span class="line-8"><span class="w">  </span><span class="p">[</span><span class="n">bindings</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">body</span><span class="p">]</span></span>
<span class="line-9"><span class="w">  </span><span class="p">(</span><span class="nf">assert-args</span></span>
<span class="line-10"><span class="w">     </span><span class="p">(</span><span class="nb">vector?</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span><span class="w"> </span><span class="s">"a vector for its binding"</span></span>
<span class="line-11"><span class="w">     </span><span class="p">(</span><span class="nb">even?</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">bindings</span><span class="p">))</span><span class="w"> </span><span class="s">"an even number of forms in binding vector"</span><span class="p">)</span></span>
<span class="line-12"><span class="w">  </span><span class="o">`</span><span class="p">(</span><span class="nf">let*</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="nb">destructure</span><span class="w"> </span><span class="n">bindings</span><span class="p">)</span><span class="w"> </span><span class="o">~@</span><span class="n">body</span><span class="p">))</span></span>
</code></pre>
<p>There’s our friend <code>let*</code>. What’s it doing there? Unfortunately, <code>(doc let*)</code> and <code>(source let*)</code> return nothing. Fortunately, as <a href="https://stackoverflow.com/a/31661863/308909">this Stack Overflow answer notes</a>, a hint about what’s really going on can be found in the Clojure source code.</p>
<h2>Because Destructuring</h2>
<p>Clojure provides a number of conveniences in comparison with other Lisps. One of these conveniences is argument destructuring. Argument destructuring allows us to write more concise and expressive code.</p>
<p>Imagine we have an vector <code>z</code> that consists of two elements. We’d like to bind the first element to the symbol <code>x</code> and the second element to the symbol <code>y</code>. Without destructuring, we’d need to write something like <code>let [x (first z) y (second z)]</code>. <em>With</em> argument destructuring, we can instead write <code>let [[x y] z]</code>.</p>
<p>The problem is that, as <a href="https://github.com/clojure/clojure/blob/ee3553362de9bc3bfd18d4b0b3381e3483c2a34c/src/clj/clojure/core.clj#L31">the comment in the Clojure source alludes to</a>, we don’t have access to the function <code>destructure</code> when we’re bootstrapping the code.<span class="connector">&#65279;<sup class="footnote-ref"><a href="#fn4" id="fnref4">4</a></sup></span> That means we can’t use destructuring in special forms directly. But what about indirectly? We could define the special form using a variation on the name we actually want to use (eg. <code>let*</code>) and then define a macro with the name we want to expose (eg. <code>let</code>). Woo!</p>
<h2>The Answer</h2>
<p>The use of <code>let*</code> as the ‘real’ special form is evident when we consider <a href="https://github.com/clojure/clojure/blob/2cc37bb56a9125a1829c73c505e32995e663059a/src/jvm/clojure/lang/Compiler.java#L44">the Java code for the Clojure compiler</a>. That code defines the various special operators we have in Clojure. Our good friend <code>def</code> is there, as is <code>if</code> and <code>quote</code>. But special forms that use destructuring aren’t. Instead, they’re replaced with their starry-eyed cousins. It’s <code>let*</code> instead of <code>let</code>, <code>loop*</code> instead of <code>loop</code>, <code>fn*</code> instead of <code>fn</code> and so on.</p>
<p>So back to our original problem: why did <code>macroexpand</code> output <code>let*</code>? Now that we understand how <code>let</code> is implemented, the docs for <code>macroexpand</code> provide the answer.</p>
<pre class="code highlight language-clj"><code><span class="line-1"><span class="p">(</span><span class="nf">doc</span><span class="w"> </span><span class="nb">macroexpand</span><span class="p">)</span></span>
<span class="line-2"><span class="c1">; =&gt; -------------------------</span></span>
<span class="line-3"><span class="c1">; =&gt; clojure.core/macroexpand</span></span>
<span class="line-4"><span class="c1">; =&gt; ([form])</span></span>
<span class="line-5"><span class="c1">; =&gt;  Repeatedly calls macroexpand-1 on form until it no longer</span></span>
<span class="line-6"><span class="c1">; =&gt;  represents a macro form, then returns it.  Note neither</span></span>
<span class="line-7"><span class="c1">; =&gt;  macroexpand-1 nor macroexpand expand macros in subforms.</span></span>
</code></pre>
<p><code>macroexpand</code> is repeatedly expanding the macros in <code>if-valid</code>. That includes not only the <code>if-valid</code> macro, but the <code>let</code> macro we unwittingly included within it. And that results in the output including <code>let*</code>.</p>
<h2>Conclusion</h2>
<p>Some of the ‘special forms’ that Clojure provides are really macros that are implemented in terms of the ‘real’ special forms. Most of the time, you’ll never notice the difference but occasionally (such as when expanding macros), these implementations will leak through. Fear not, you’re just improving your understanding of how Clojure works!&nbsp;&#10042;</p>
<section class="footnotes">
<ol>
<li id="fn1">
<p>OK, so strap yourself in because this one’s long.</p>
<p>First, there’s a mistake in the code listing in Chapter 8 that shows the output from <code>macroexpand</code> as being code to be input. Higginbotham follows the common documentation practice of showing the output of evaluated code as a comment; however, the Chapter 8 listing mistakenly omits this. This has been corrected in the code listing in this post.</p>
<p>Second, in Clojure 1.10.0, the compiler will throw an error if you try to input the code as written in Chapter 8. This is because <code>macroexpand</code> is now subject to a spec that prevents the use of simple symbols (such as <code>my-error-name</code>). These symbols <a href="https://clojure.org/guides/weird_characters">must be appended by a <code>#</code></a> so that a unique unqualified symbol will be generated. This has also been corrected (and an example generated symbol is used in the output).</p>
<p>Third, when I run the code with Clojure 1.10.0, my output fully qualifies all of the symbols. That is, rather than <code>(println :success)</code>, I see <code>(clojure.core/println :success)</code>. For legibility reasons, I’ve left this out of the output but if you see the same thing, don’t freak out.</p>
<p>Phew. <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2">
<p>Geez, this is becoming a thing, isn’t it?</p>
<p>So, first, some terminology. When discussing the basic building blocks of Lisps, there’s a tendency online to loosely throw around the terms primitives, special operators and special forms. As I understand things, technically (a) <strong>primitives</strong> refers to elements of the language like numbers, strings, symbols, booleans, etc; (b) <strong>special operators</strong> refers to special symbols (eg. <code>def</code>) that are treated differently to other symbols; and (c) <strong>special forms</strong> refers to expressions that have as their operator a special operator (eg. <code>(def x true)</code>).</p>
<p>Now, in this post, I tend to follow the dominant pattern in the Clojure community and refer to both special operators <em>and</em> special forms as ‘special forms’. Confusing, I know.</p>
<p>As for the minimum number of special forms that are necessary to implement a Lisp, the specific number depends to some degree on how convenient you want to make the language. <a href="https://stackoverflow.com/q/3482389/308909">Somewhere between five and ten </a>seems to be the rough minimum. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3">
<p>Clojure’s documentation says that it <em>is</em> a special form so who am I to say this? I’m a guy on the Internet. Fight me. <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
<li id="fn4">
<p>This is beyond my understanding at the moment but presumably it would be possible to define a Lisp where <code>destructure</code> is itself a special form. I’d guess that Clojure doesn’t do that because you can achieve the desired effect with macros and doing so allows for the number of special forms to remain small. <a href="#fnref4" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>


  </article>
</section>

      <footer class="post">
        <p><small>This post was written by <a href="https://inqk.net/">Michael Camilleri</a>, a person on the Internet. If you have any comments, please reach out on <a href="https://micro.blog/pyrmont/">Micro.blog</a> or  <a href="https://twitter.com/pyrmont/">Twitter</a>. Original work placed in the public domain. All rights are disclaimed. <a href="/licence.html">Why?</a></small></p>
      </footer>
    </div>

    <script src="/assets/js/barefoot.min.js?v=2daa2b27c8b7174fdff1f614d852c8ece5845587"></script>
    <script>
      lf = new BareFoot();
      lf.init();
    </script>

  </body>
</html>

